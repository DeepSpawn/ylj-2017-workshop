// Generated by BUCKLESCRIPT VERSION 1.7.1, PLEASE EDIT WITH CARE
'use strict';

var Bmap     = require("bs-containers/lib/js/src/bmap.js");
var Bopt     = require("bs-containers/lib/js/src/bopt.js");
var Curry    = require("bs-platform/lib/js/curry.js");
var Mocha    = require("mocha");
var Bfloat   = require("bs-containers/lib/js/src/bfloat.js");
var Assert   = require("assert");
var Bstring  = require("bs-containers/lib/js/src/bstring.js");
var Helpers  = require("../helpers.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");

var compare = Caml_obj.caml_compare;

var IMap = Bmap.Make(/* module */[/* compare */compare]);

function koans() {
  Mocha.describe("Mapionaries", function () {
        Mocha.it("Map.Make is a module functor that takes a module", function () {
              Bmap.Make([Bstring.compare]);
              Assert.ok(/* true */1);
              return /* () */0;
            });
        Mocha.it("Map.Make takes any module with { type: t, compare: t => t => int }", function () {
              Bmap.Make([Bfloat.compare]);
              Assert.ok(/* true */1);
              return /* () */0;
            });
        Mocha.it("Map.Make can take an arbitrary module to wrap types without a predefined OrderedType interface", function () {
              var compare = Caml_obj.caml_compare;
              Bmap.Make(/* module */[/* compare */compare]);
              Assert.ok(/* true */1);
              return /* () */0;
            });
        Mocha.it("Maps can be created empty", function () {
              Assert.equal(IMap[/* empty */0], Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("Maps can be initialised with a single key value pair", function () {
              Assert.equal(Curry._2(IMap[/* singleton */4], 1, "value"), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("or from a list of key-value pairs", function () {
              Assert.equal(Curry._1(IMap[/* size */25], Curry._1(IMap[/* fromList */30], /* :: */[
                            /* tuple */[
                              1,
                              "a"
                            ],
                            /* :: */[
                              /* tuple */[
                                2,
                                "b"
                              ],
                              /* [] */0
                            ]
                          ])), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("they can also be converted back to a list", function () {
              Assert.equal(Curry._1(IMap[/* toList */32], Curry._1(IMap[/* fromList */30], /* :: */[
                            /* tuple */[
                              1,
                              "a"
                            ],
                            /* :: */[
                              /* tuple */[
                                2,
                                "b"
                              ],
                              /* [] */0
                            ]
                          ])), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("checking for an empty dictionary is easy", function () {
              Assert.equal(Curry._1(IMap[/* isEmpty */21], IMap[/* empty */0]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("you can also check if a key is present in the dictionary", function () {
              Assert.equal(Curry._2(IMap[/* mem */2], 1, Curry._2(IMap[/* singleton */4], 1, "a")), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("or get the value associated with the key", function () {
              Assert.equal(Curry._2(IMap[/* get */26], 1, Curry._2(IMap[/* singleton */4], 1, "a")), /* Some */[Helpers.__(/* () */0)]);
              return /* () */0;
            });
        Mocha.it("a key-value pair can be added to the dictionary", function () {
              Assert.equal(Curry._2(IMap[/* get */26], 2, Curry._3(IMap[/* add */3], 2, "b", Curry._2(IMap[/* singleton */4], 1, "a"))), /* Some */[Helpers.__(/* () */0)]);
              return /* () */0;
            });
        Mocha.it("inserting can also overwrite the value associated with a key", function () {
              Assert.equal(Curry._2(IMap[/* get */26], 1, Curry._3(IMap[/* add */3], 1, "b", Curry._2(IMap[/* singleton */4], 1, "a"))), /* Some */[Helpers.__(/* () */0)]);
              return /* () */0;
            });
        Mocha.it("updating a value works similarly", function () {
              Assert.equal(Curry._2(IMap[/* get */26], 1, Curry._3(IMap[/* update */28], 1, function () {
                            return /* Some */["b"];
                          }, Curry._2(IMap[/* singleton */4], 1, "a"))), /* Some */[Helpers.__(/* () */0)]);
              return /* () */0;
            });
        Mocha.it("but knows about the current value", function () {
              Assert.equal(Curry._2(IMap[/* get */26], 1, Curry._3(IMap[/* update */28], 1, function (v) {
                            return /* Some */[Bopt.get("", v) + "b"];
                          }, Curry._2(IMap[/* singleton */4], 1, "a"))), /* Some */[Helpers.__(/* () */0)]);
              return /* () */0;
            });
        Mocha.it("updating can add a new value", function () {
              Assert.equal(Curry._2(IMap[/* get */26], 2, Curry._3(IMap[/* update */28], 2, function () {
                            return /* Some */["b"];
                          }, Curry._2(IMap[/* singleton */4], 1, "a"))), /* Some */[Helpers.__(/* () */0)]);
              return /* () */0;
            });
        Mocha.it("or even remove a value", function () {
              Assert.equal(Curry._2(IMap[/* get */26], 1, Curry._3(IMap[/* update */28], 1, function () {
                            return /* None */0;
                          }, Curry._2(IMap[/* singleton */4], 1, "a"))), /* Some */[Helpers.__(/* () */0)]);
              return /* () */0;
            });
        Mocha.it("of course there is a more direct way to remove a value too", function () {
              Assert.equal(Curry._2(IMap[/* get */26], 1, Curry._2(IMap[/* remove */5], 1, Curry._2(IMap[/* singleton */4], 1, "a"))), /* Some */[Helpers.__(/* () */0)]);
              return /* () */0;
            });
        Mocha.it("you can get the list of keys", function () {
              Assert.equal(Curry._1(IMap[/* keysList */35], Curry._2(IMap[/* singleton */4], 1, "a")), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("or the list of values", function () {
              Assert.equal(Curry._1(IMap[/* valuesList */36], Curry._2(IMap[/* singleton */4], 1, "a")), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("mapping works similarly as with lists", function () {
              Assert.equal(Curry._1(IMap[/* valuesList */36], Curry._2(IMap[/* map */19], function (_, v) {
                            return v + "c";
                          }, Curry._1(IMap[/* fromList */30], /* :: */[
                                /* tuple */[
                                  1,
                                  "a"
                                ],
                                /* :: */[
                                  /* tuple */[
                                    2,
                                    "b"
                                  ],
                                  /* [] */0
                                ]
                              ]))), Helpers.__(/* () */0));
              return /* () */0;
            });
        return /* () */0;
      });
  return /* () */0;
}

exports.IMap  = IMap;
exports.koans = koans;
/* IMap Not a pure module */
