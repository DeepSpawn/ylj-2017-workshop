// Generated by BUCKLESCRIPT VERSION 1.7.1, PLEASE EDIT WITH CARE
'use strict';

var Blist      = require("bs-containers/lib/js/src/blist.js");
var Mocha      = require("mocha");
var Assert     = require("assert");
var Helpers    = require("../helpers.js");
var Caml_obj   = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

function charSort(a, b) {
  var lt = +(a < b);
  var eq = +(a === b);
  if (lt) {
    return -1;
  } else if (eq) {
    return 0;
  } else {
    return 1;
  }
}

function koans() {
  Mocha.describe("Lists", function () {
        Mocha.it("list literals are denoted by brackets", function () {
              Assert.equal(/* :: */[
                    1,
                    /* :: */[
                      2,
                      /* :: */[
                        3,
                        /* [] */0
                      ]
                    ]
                  ], Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("length gives the length of a list", function () {
              Assert.equal(Blist.length(/* :: */[
                        1,
                        /* :: */[
                          2,
                          /* :: */[
                            3,
                            /* [] */0
                          ]
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("isEmpty determines if a list is empty", function () {
              Assert.equal(Blist.is_empty(/* [] */0), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("exists determines if a list is empty", function () {
              Assert.ok(Blist.exists(Helpers.__(/* () */0), /* :: */[
                        1,
                        /* :: */[
                          2,
                          /* :: */[
                            3,
                            /* [] */0
                          ]
                        ]
                      ]));
              return /* () */0;
            });
        Mocha.it("head_opt returns an optional containing the first item in a list", function () {
              Assert.equal(Blist.head_opt(/* :: */[
                        1,
                        /* :: */[
                          2,
                          /* :: */[
                            3,
                            /* [] */0
                          ]
                        ]
                      ]), /* Some */[Helpers.__(/* () */0)]);
              return /* () */0;
            });
        Mocha.it("head_opt returns None if the list is empty", function () {
              Assert.equal(Blist.head_opt(/* [] */0), /* Some */[Helpers.__(/* () */0)]);
              return /* () */0;
            });
        Mocha.it("take returns the first n items in a list", function () {
              Assert.equal(Blist.take(2, /* :: */[
                        1,
                        /* :: */[
                          2,
                          /* :: */[
                            3,
                            /* [] */0
                          ]
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("drop returns the list without the first n items", function () {
              Assert.equal(Blist.drop(2, /* :: */[
                        1,
                        /* :: */[
                          2,
                          /* :: */[
                            3,
                            /* [] */0
                          ]
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("filter returns the elements that return true for a predicate function", function () {
              Assert.equal(Blist.filter(function (x) {
                        return +(x % 2 === 0);
                      }, /* :: */[
                        1,
                        /* :: */[
                          2,
                          /* :: */[
                            3,
                            /* :: */[
                              4,
                              /* [] */0
                            ]
                          ]
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("all tests whether all elements of a list return true for a predicate function", function () {
              Assert.equal(Blist.for_all(function (x) {
                        return +(x % 2 === 0);
                      }, /* :: */[
                        2,
                        /* :: */[
                          4,
                          /* [] */0
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("repeat returns a list with n copies of a value", function () {
              Assert.equal(Blist.repeat(4, /* :: */[
                        1,
                        /* [] */0
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("sort sorts a list with a custom function", function () {
              Assert.equal(Blist.sort(charSort, /* :: */[
                        /* "c" */99,
                        /* :: */[
                          /* "a" */97,
                          /* :: */[
                            /* "b" */98,
                            /* [] */0
                          ]
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("but you can just pass sort the Pervasives.compare function", function () {
              Assert.equal(Blist.sort(Caml_obj.caml_compare, /* :: */[
                        /* "c" */99,
                        /* :: */[
                          /* "a" */97,
                          /* :: */[
                            /* "b" */98,
                            /* [] */0
                          ]
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("[x, ...list] prepends the list with x", function () {
              Assert.equal(/* :: */[
                    1,
                    /* :: */[
                      2,
                      /* :: */[
                        3,
                        /* [] */0
                      ]
                    ]
                  ], Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("List.cons is the cons operator", function () {
              Assert.equal(Blist.cons(1, /* :: */[
                        2,
                        /* :: */[
                          3,
                          /* [] */0
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("append puts 2 lists together", function () {
              Assert.equal(Blist.append(/* :: */[
                        1,
                        /* :: */[
                          2,
                          /* [] */0
                        ]
                      ], /* :: */[
                        3,
                        /* :: */[
                          4,
                          /* [] */0
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("concat appends the elements in a list of lists", function () {
              Assert.equal(Blist.concat(/* :: */[
                        /* :: */[
                          1,
                          /* :: */[
                            2,
                            /* [] */0
                          ]
                        ],
                        /* :: */[
                          /* :: */[
                            3,
                            /* :: */[
                              4,
                              /* [] */0
                            ]
                          ],
                          /* [] */0
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("map applies a function to every element of a list", function () {
              Assert.equal(Blist.map(function (x) {
                        return (x << 1);
                      }, /* :: */[
                        1,
                        /* :: */[
                          2,
                          /* :: */[
                            3,
                            /* [] */0
                          ]
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("map2 applies a function to elements from 2 lists", function () {
              Assert.equal(Blist.map2(Caml_int32.imul, /* :: */[
                        1,
                        /* :: */[
                          2,
                          /* :: */[
                            3,
                            /* [] */0
                          ]
                        ]
                      ], /* :: */[
                        4,
                        /* :: */[
                          5,
                          /* :: */[
                            6,
                            /* [] */0
                          ]
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("foldl reduces a list from the left", function () {
              Assert.equal(Blist.fold_left(function (x, y) {
                        return /* :: */[
                                y,
                                x
                              ];
                      }, /* :: */[
                        "a",
                        /* [] */0
                      ], /* :: */[
                        "b",
                        /* :: */[
                          "c",
                          /* :: */[
                            "d",
                            /* [] */0
                          ]
                        ]
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        Mocha.it("foldr reduces a list from the right", function () {
              Assert.equal(Blist.fold_right(function (x, y) {
                        return /* :: */[
                                x,
                                y
                              ];
                      }, /* :: */[
                        "b",
                        /* :: */[
                          "c",
                          /* :: */[
                            "d",
                            /* [] */0
                          ]
                        ]
                      ], /* :: */[
                        "a",
                        /* [] */0
                      ]), Helpers.__(/* () */0));
              return /* () */0;
            });
        return /* () */0;
      });
  return /* () */0;
}

exports.charSort = charSort;
exports.koans    = koans;
/* Blist Not a pure module */
